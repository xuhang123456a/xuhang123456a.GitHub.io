---
layout: post
title: A_02 类型系统
date: 2026-01-31 23:04:21 +0000
author: xuhang
tags: ["编程", "编程语言", "csharp"]
---

# A_02 类型系统

- [值类型与引用类型]()
    - [引用类型]()
    - [值类型]()
    - [值类型与引用类型的差别]()
    - [引用类型和值类型有哪些]()
        - [引用类型]()
        - [值类型]()
    - [什么情况下使用值类型]()
- [装箱和拆箱]()

C# 所有类型全部从 System.Object 类派生

派生类对象可以隐式转换为基类对象（数据类型转换讲究精度，而不是讲究大小关系，例如，白马可以说是马，而马不能说成白马）

# 值类型与引用类型

操作符new所做的事：

1. 计算所需内存空间，包括所有基类在内的所有实例字段所需字节数，此外，为了方便mono运行时管理对象，还有一些额外的信息需要托管堆为其分配空间，如类型对象指针和同步索引块。
2. 完成计算后，就要为对象在托管堆上分配所需的内存空间了，分配的所有字节都设为0。
3. 接下来初始化对象的“类型对象指针”以及“同步块索引”。
4. 调用类型的实例构造器，传递在使用 new 关键字时所指定的实参，编译器会自动调用当前类型的基类构造器，每个类型的构造器都负责初始化该类型定义的实例字段
5. 最后会返回指向新建对象的一个引用。也就是说新建的变量是一个指向某类型对象的引用，而非对象本身。

## 引用类型

1. 存储引用类型对象的内存空间须从托管堆上分配
2. 每个对象都有一些额外的成员为 mono 运行时提供操作该对象的信息，因而堆上分配空间时也要考虑这些成员的空间，且这些成员必须被初始化
3. 对象中其他字段的字节总是0
4. 对象的回收工作由GC处理

## 值类型

1. 值类型不派生其他任何类型
2. 值类型是以值方式传递的
3. 值类型派生自System.ValueType

## 值类型与引用类型的差别

- 值类型与引用类型最大的区别就是基于值类型的变量直接包含值，引用类型变量的赋值只复制对对象的引用，不复制对象本身
- 值类型不能派生出其他类型，所有值类型都是隐式密封的，以防止将值类型用作其他类型的基类
- 值类型没有引用类型中的额外信息，也会减少GC的次数

引用类型总是分配在托管堆上，值类型并非总是分配在线程栈上，有如下例外：

数组中的元素

引用类型中的值类型字段

迭代器块中的局部变量

闭包情况下匿名函数中的局部变量

这几种情况下的值类型实例如果分配在线程栈上，有可能会出现线程栈中的方法已经调用结束，但还是会访问这些值的情况，因此要被分配到托管堆上，以满足在方法返回之后还能够被访问的要求

## 引用类型和值类型有哪些

### 引用类型

所有被称为“类”的类型

Class

Interface

Delegate

Object

string

### 值类型

所有值类型包括所有枚举的基类System.Enum都必须派生自System.ValueType，

结构

- 数字型结构
- 布尔型结构
- 用户自定义的结构：DataTime

枚举

System.IO.FileAttributes

System.Drawing.FontStyle

## 什么情况下使用值类型

- 类型的实例较小时，比如Vector3
- 想减少受到GC影响的时候

# 装箱和拆箱

向要求引用类型的方法传递值类型时，会自动生成代码对其进行装箱，例如ArrayList

值类型实例进行装箱时的步骤：

1. 在托管堆中分配内存，注意：除了值类型各个字段所需的内存之外，还要加上托管堆所有对象都有的两个额外成员（类型对象指针和同步索引块）所需的内存
2. 将值类型的字段复制到新分配的堆内存中
3. 返回对象地址，即对象的引用
    拆箱的过程：（其实就是获取引用的过程，将值从托管堆上的对象中复制到值类型实例中，是拆箱之后紧跟的一步复制过程，而非拆箱本身）
4. 获取已经装箱的Vector3对象中各个字段的地址，这个过程便是拆箱
5. 将已经装箱的Vector3对象中各个字段的值从托管堆上复制到线程栈的新的值类型Vector3的实例中去
