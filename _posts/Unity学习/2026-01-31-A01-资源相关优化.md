---
layout: post
title: A01-资源相关优化
categories: [unity,游戏开发]
date: 2026-01-31
---

# A01-资源相关优化

- [纹理（Texture）优化]()
- [网格（Mesh）优化]()
- [动画（AnimationClip）优化]()
- [音频（AudioClip）优化]()
- [模型优化]()
- [材质（Material）优化]()
- [着色器优化（shader）]()
- [字体（Font）优化]()
- [文本（TextAsset）优化]()

纹理、网格、动画片段和音频片段是最容易造成较大内存开销的资源。

# 纹理（Texture）优化

以下来自[Unity 性能优化：资源篇](https://zhuanlan.zhihu.com/p/407249510)

纹理的资源优化主要集中于下面几点：

- 纹理大小
- 压缩格式
- 导入设置

需要遵循如下原则：

- 降低最大分辨率
- 采用二次幂压缩格式
- 制作纹理图集
- 取消勾选 Read/Write Enabled
- 禁用多余的Mip Map：Mip Map贴图在2D精灵和UI图形这类大小始终一直的纹理上并无用处

**1、降低最大分辨率**

![.png](image/.png)

**2、对于纹理的压缩**

![-1.png](image/-1.png)

![-2.png](image/-2.png)

注意：

除了由于压缩逻辑不同带来的加载带宽减少之外，同时还需要了解像ETC1、PVRTC4等这类在内存中不需要进行解压，而是可以直接被GPU支持，所以相比其他压缩格式通常会有最好的性能表现

**3、取消勾选Read/Write Enabled**

该功能是为了使得游戏开发者可以通过C#脚本调用对与图片的读取与写入的控制，很明显，这是由CPU来控制实现的，所以为了可以使得CPU获取数据，需要在内存中备份一份让CPU访问。同时为了图形渲染与显示，又会将其加载到显存中为GPU提供数据。简单来说，该选项会在游戏运行时，分别在CPU内存与GPU内存中备份出一张贴图，如果你并不需要对于纹理进行读写操作，可以尝试关闭该选项，这样就可以避免游戏运行时占用多余的内存

**4、禁用多余的Mip Map**

Mip Map类似于模型的LOD，同样是一种基于渲染距离改变渲染贴图精度的技术。其优势是在物体距离渲染距离比较远时，可以节省性能。但是使用Mip Map时会增大内存占用量。Mip map的技术原理是根据原始图进行2的幂次方的递减来生成一组不同精度的图片。当游戏运行时，会将这组图片加载到内存中，然后根据渲染的距离不同，来使用不同精度的图片。

**Mip map会增大多大的内存占用量呢**

在我们使用Mip map时，假设大小为256X256，并且会生成8张不同精度的图片。根据2的幂次方进行递减计算每张贴图大小并累加。这样最终得到的图片组的体积大概比原来的单张贴图大33%

而Unity所支持的纹理最小为32X32,也就是最小的纹理也会额外的产生三层低精度纹理：16X16、4X4、1X1，这就是为什么很多文章介绍到使用Map mip会说其大约会增加33%的内存占用量。虽然Mip map本身是一种性能优化的技术，但是在2D精灵或者UI元素这些不会改变渲染精度的纹理上，只会占用多余的内存，所以在2D精灵或者UI元素上使用纹理时记得不要勾选Mip map。

**5、打包图集**

图集的打包主要是优化UI图形渲染过程中Draw call的数量，其基本原理也是通过UI元素合批来减少Draw Call，进入提升CPU的性能表现

[你所需要了解的几种纹理压缩格式原理](https://blog.uwa4d.com/archives/USparkle_Texture.html)

[如何修复警告“只有宽度/高度为 4 的倍数的纹理才能压缩为 ETC2 格式”？](https://gamedev.stackexchange.com/questions/204769/how-to-fix-the-warning-only-textures-with-width-height-being-multiple-of-4-ca)

[精灵图集](https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteAtlas.html)

[Unity之UGUI精灵图集(Sprite Atlas)保姆式教程](http://jingyan.idoubi.net/5318.html)

# 网格（Mesh）优化

1. Normal、Color和Tangent
    Mesh资源的数据会含有大量的Normal、Color和Tangent数据，这些数据将大幅增加Mesh资源的文件体积和内存占用，其中，Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。
    更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，

# 动画（AnimationClip）优化

[Unity动画文件优化探究](https://blog.uwa4d.com/archives/Optimization_Animation.html)

[Unity性能优化 — 动画模块](https://blog.uwa4d.com/archives/UWA_ReportModule6.html)

[动画优化：关于AnimationClip的三两事](https://blog.uwa4d.com/archives/UWA_Pipeline22.html)

# 音频（AudioClip）优化

[Unity 音频优化总结](https://blog.csdn.net/chenfujun818/article/details/81710895)

[Unity音频优化实践](https://zhuanlan.zhihu.com/p/357031530)

# 模型优化

以下来自[Unity 性能优化：资源篇](https://zhuanlan.zhihu.com/p/407249510)

![-3.png](image/-3.png)

**1、禁用掉Reader/Write Enables:**

点击模型，可以在Inspector面板看到这些设置选项，类似于纹理，如果在游戏中，你不需要对模型进行修改，可以禁用掉Reader/Write Enables来避免数据的备份而占用多余的内存，我们可以在Unity官方文档中找到相关介绍：

翻译过来就是：

> 启用此选项后，Unity 会将 Mesh数据上传到 GPU可寻址内存，但也会将其保存在 CPU 可寻址内存中。这意味着Unity可以在运行时访问 Mesh数据，可以从脚本中访问它。
> 
> 
> 而禁用此选项后，Unity 会将 Mesh 数据上传到 GPU可寻址内存，然后将其从 CPU 可寻址内存中删除
> 
> 
> 默认情况下，此选项处于禁用状态。在大多数情况下，要节省运行时内存使用量，请禁用此选项
> 
> 
> 而对于模型本身来说，尽量避免模型留有多余的面数。尤其是移动端。因为高精度模型除了本身所带来的压力外，在其他方面也有诸多的性能挑战

注意：某些情况下禁用Reader/Write Enables会使得Mesh Collider不可用，具体信息在Unity官方文档中有提到：

![-4.png](image/-4.png)

**2、尽量不要勾选不需要的功能**

选项在Unity中，某些功能即使你未使用到，也会 消耗一定的资源去维护其状态。类似上面的Reader/Write Enables选项,所以用不到的功能我们可以考虑尽量的去禁用掉

**3、设置一些关于质量与性能的选项**

Unity提供了一些对模型进行优化的选项，可以查阅Unity官方文档来阅读了解他们，这里也简要的列出：

![-5.png](image/-5.png)

通过上面一张图片可以看出，影响模型表现与游戏性能的选项有下面几个：

- Mesh Compression：通过使用网格边界和每个组件较低的位深度来压缩网格数据，增加压缩率会降低网格的精度。最好在 Mesh 看起来与未压缩版本没有太大区别的情况下将其调得尽可能高。这对于优化游戏大小很有用
- Optimize Mesh：确定三角形在网格中列出的顺序以获得更好的 GPU 性能，默认都会勾选
- Normals:如果网格模型既不是法线贴图也不受实时光照影响，就选用None,这样也能够很好的提升性能表现

其实，Unity设置了一些通过程序控制模型质量来改变性能表现的选项，但是不建议使用，预期通过这些选项来调整性能表现，还不如直接让美术直接处理模型。毕竟他们更加专业，可以更好的保证模型的表现效果与性能表现的平衡。

**4、使用LOD**

关于LOD，其实应该在渲染这一段来讲，但是这个技术又与模型网格有很大的关系，所以提前介绍一下LOD即Levels of Detail，翻译过来就是多层次细节，类似与纹理渲染的Mip map技术，同样是一种根据渲染距离设置渲染精度的一种技术。其实现方式是在游戏开发时，美术根据不同的渲染距离制作一组不同精度的模型，导入到Unity通过LOD组件连接其这一组模型，并设置相关参数。这样在游戏运行时，就会在不同的距离有不同的渲染精度：

![-6.png](image/-6.png)

这是Unity官方文档的一个案例，可以看出，随着渲染距离的增加，渲染精度逐渐下降，直到最终被剔除，这样做的优势是保证游戏画面表现的同时，可以最大程度降低渲染压力。简单的理解，如果不采用LOD，随着距离增加，物体占用的屏幕像素就会越少，那么单位像素的三角面数就会越多。单位的渲染压力就会增大。画面表现需求不高的地方渲染压力反而更高，这显然是不合理的。所以就需要通过LOD来解决这样的问题。当然这种技术本身也是有相当大的缺陷的，首先就是会增大包体的体积，同时也会增加美术的工作量。所以在实际开发中，一般只会对一些重要的对象使用该技术

# 材质（Material）优化

# 着色器优化（shader）

[Shader：优化破解变体的“影分身”之术](https://zhuanlan.zhihu.com/p/337308829)

# 字体（Font）优化

# 文本（TextAsset）优化

TOCTextureUnity(httpszhuanlan.zhihu.comp)*******ReadWritenabled*MipMapMipMapUI**1**!.png(en-resourcetabase)**2**!.png(en-resourcetabase)!.png(en-resourcetabase)TC1PVRTC4GPU**3ReadWritenabled**PUPUPUGPUPUGPU**4MipMap**MipMapLODMipMapMipmap**Mipmap**MipmapX256UnityX32X16X4X1MapmipMipmapUIUIMipmap**5**UIrawllUIrawllPU(httpslog.uwa4d.comrchivesUSparkle_Texture.html)TC2(httpsgamedev.stackexchange.comquestionshow-to-fix-the-warning-only-textures-with-width-height-being-multiple-of-4-ca)(httpsocs.unity3d.comn.3Manuallass-SpriteAtlas.html)UnityUGUI(Spritetlas)(httpjingyan.idoubi.net.html)Mesh.NormalolorTangentMeshNormalolorTangentMesholorNormalMaxMayaTangentMeshrawlltchingnimationClipUnity(httpslog.uwa4d.comrchivesOptimization_Animation.html)Unity(httpslog.uwa4d.comrchivesUWA_ReportModule6.html)nimationClip(httpslog.uwa4d.comrchivesUWA_Pipeline22.html)udioClipUnity(httpslog.csdn.nethenfujun818rticletails)Unity(httpszhuanlan.zhihu.comp)Unity(httpszhuanlan.zhihu.comp)!.png(en-resourcetabase)**1ReaderWritenables**InspectorReaderWritenablesUnityUnityMeshGPUPUUnityMeshUnityMeshGPUPUReaderWritenablesMesholliderUnity!.png(en-resourcetabase)**2**UnityReaderWritenables**3**UnityUnity!.png(en-resourcetabase)*MeshompressionMesh*OptimizeMeshGPU*NormalsNoneUnity**4LOD**LODLODLevelsoftailMipmapUnityLOD!.png(en-resourcetabase)UnityLODLODMaterialshaderShader(httpszhuanlan.zhihu.comp)ontTextAsset

