---
layout: post
title: A_01_面向对象
categories: [编程语言,学习]
date: 2026-01-31
---

# A_01 面向对象

- [面向对象的三大特征]()
- [C#结构体和类的区别]()
- [C#密封类和普通类的区别]()
- [C#接口和抽象类的区别]()
- [重载和重写]()
- [依赖注入]()

# 面向对象的三大特征

封装：为了隐藏细节，便于修改、维护

继承：子类会继承父类的属性和方法（例子：DVD、CD、存储媒体）

多态：一个方法或类型具有多种实现

- 静态多态：方法重载、运算符重载
- 动态多态：通过虚方法实现

# C#结构体和类的区别

C# 中的结构体和类都是用于定义自定义数据类型的，但它们之间有以下区别：

- 语法不同：结构体使用 struct 关键字定义，类使用 class 关键字定义。
- 存储位置不同：结构体通常存储在栈上，而类通常存储在堆上。
- 复制行为不同：结构体复制时会复制整个值，而类复制时只会复制引用。
- 继承不同：结构体不支持继承，而类支持继承。
- 默认访问权限不同：结构体的成员默认为 public，而类的成员默认为 private。
- 需要显式实现默认构造函数：结构体没有默认的无参构造函数，需要显式实现。
- 性能不同：由于结构体存储在栈上，所以访问速度更快，但是在进行大量操作时，结构体的复制和传递开销较大，而类由于存储在堆上，访问速度较慢，但是复制和传递时只需要复制引用，开销较小。

总的来说，如果定义的是简单的数据类型，比如坐标、颜色等，那么使用结构体更加合适。如果定义的是复杂的对象，需要继承、多态等特性，则使用类更加合适。

# C#密封类和普通类的区别

C#中有两种类的定义 - 普通类和密封类。两者都可以定义实例字段，实例属性，实例方法等，但是它们之间有些区别。以下是普通类和密封类之间的区别：

1. 继承- 普通类可以被继承，而密封类不能被继承。
2. 实例化- 普通类的实例可以被创建，而密封类的实例不能被创建。
3. 代码安全性- 密封类可以提高代码的安全性，因为它们不能被其他类继承或更改其行为。这对于安全性要求高的应用程序很有用。
4. 多态性- 普通类可以通过继承和多态性来实现本质不同的子类，而密封类不允许这样做。
5. Overriding- 使用密封类时，不能使用关键字override来覆盖它的方法。

综上所述，密封类更在意代码安全性，不能被继承和实例化，但是也限制了使用，不够灵活。而普通类更加灵活，可以被继承和实例化，允许多态性和overriding。

# C#接口和抽象类的区别

C#中接口和抽象类的区别如下：

1. 抽象类是一种特殊的类，只是不能被实例化，而接口是一种特殊的类，只是不能被实例化。
2. 抽象类可以包含成员变量，而接口不能包含成员变量。
3. 抽象类可以包含方法的实现，而接口不能包含方法的实现。
4. 一个类只能继承一个抽象类，但可以实现多个接口。

C#中的接口和抽象类类似，它们都是用于实现多态性和封装性的机制，但是它们之间有以下区别：

- 实现方式：抽象类是一个类，而接口是一组方法的集合。抽象类可以包含抽象方法和非抽象方法，而接口只能包含抽象方法和属性。
- 继承关系：抽象类可以被其他类继承，而接口只能被实现。
- 实现数量：一个类只能继承一个抽象类，但是可以实现多个接口。
- 成员访问修饰符：抽象类的成员可以有public、protected、internal、private等访问修饰符，而接口的成员只能是public。
- 字段和常量：抽象类可以包含字段和常量，而接口只能包含常量。

总之，抽象类主要用于实现类的继承、封装和多态性，而接口主要用于实现类的多重继承和规范。当需要为多个不相关的类提供公共接口时，使用接口更为合适；当需要为一组相关的类提供通用的基类或实现通用的方法时，使用抽象类更为合适

C#中有两种用于抽象数据类型的构造：接口和抽象类。这两者的主要区别在于以下几点：

1. 实现- 抽象类可以有部分实现和未实现的方法，而接口不能有任何实现。接口只包含方法的签名，而不包含方法的实现。
2. 继承- 一个类只能继承一个抽象类，而一个类可以实现多个接口。
3. 多态性- 接口者多态性，可以将一个对象实现的多个接口强制类型转换成任何一个这些接口的类型。而抽象类只能具有一个基类，并且不能同时实现多个类。
4. 成员- 接口只能包含方法，事件和属性。抽象类可以包含字段，构造函数以及其他任何可以在类中定义的成员。
5. 构造函数- 接口不能定义构造函数，而抽象类可以有构造函数。

综上所述，抽象类更适合用于需要具有通用性的代码结构，接口则适用于实现多态性和设计模式的要求，不同场合有不同的应用。同时，如果需要在不同的层级和基类中定义公共行为，抽象类会更加适合，但需要注意继承和复杂性问题。

[c#中抽象类和接口的相同点跟区别](https://blog.csdn.net/fxh_hua/article/details/4464739)

# 重载和重写

# 依赖注入

[如何用最简单的方式解释依赖注入？依赖注入是如何实现解耦的?](https://www.zhihu.com/search?type=content&q=)

TOCVD***structlass****publicprivate**-.-.-.-.-.Overriding-overrideoverriding....****publicprotectedinternalprivatepublic*.-.-.-.-.-(httpslog.csdn.netxh_huarticletails)(httpswww.zhihu.comsearchtypeontentq)

